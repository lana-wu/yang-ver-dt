<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY RFC2119 SYSTEM "reference.RFC.2119.xml">
  <!ENTITY RFC5246 SYSTEM "reference.RFC.5246.xml">
  <!ENTITY RFC6020 SYSTEM "reference.RFC.6020.xml">
  <!ENTITY RFC6241 SYSTEM "reference.RFC.6241.xml">
  <!ENTITY RFC6242 SYSTEM "reference.RFC.6242.xml">
  <!ENTITY RFC6536 SYSTEM "reference.RFC.6536.xml">
  <!ENTITY RFC7895 SYSTEM "reference.RFC.7895.xml">
  <!ENTITY RFC7950 SYSTEM "reference.RFC.7950.xml">
  <!ENTITY RFC8199 SYSTEM "reference.RFC.8199.xml">
  <!ENTITY RFC8040 SYSTEM "reference.RFC.8040.xml">
  <!ENTITY RFC8174 SYSTEM "reference.RFC.8174.xml">
  <!ENTITY RFC8342 SYSTEM "reference.RFC.8342.xml">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" ipr="trust200902" docName="draft-wilton-netmod-yang-ver-selection-01">
  <front>
    <title abbrev="YANG Schema Selection">YANG Schema Selection</title>

    <author initials="R." surname="Wilton" fullname="Robert Wilton">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <email>rwilton@cisco.com</email>
      </address>
    </author>
    <author initials="R." surname="Rahman" fullname="Reshad Rahman">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <email>rrahman@cisco.com</email>
      </address>
    </author>
    <author initials="J." surname="Clarke" fullname="Joe Clarke">
      <organization>Cisco Systems, Inc.</organization>
      <address>
        <email>jclarke@cisco.com</email>
      </address>
    </author>
    <date/>
    <abstract>
      <t>
	This document defines a mechanism to allow clients, using NETCONF or RESTCONF, to configure
	and choose YANG schema for interactions with a server out of a set of available YANG schemas
	supported by a server.  This functionality can help servers support clients using older
	revisions of YANG modules even if later revisions contain non-backwards-compatible changes.
	It can also be used to allow clients to select between YANG schema defined by different
	organizations.</t>
      <t>This draft provides a solution to YANG versioning requirements 3.1 and 3.2.</t>
    </abstract>

  </front>
  <middle>
    <section anchor="terminology" title="Terminology and Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
      "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted
      as described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when,
      they appear in all capitals, as shown here.</t>
      
      <t>This document uses terminology introduced in the YANG versioning requirements <xref
      target="I-D.verdt-netmod-yang-versioning-reqs"/>, YANG Module Versioning
      <xref target="I-D.verdt-netmod-yang-module-versioning"/> and YANG Packages
      <xref target="I-D.rwilton-netmod-yang-packages"/>.</t>
      <t>This document makes of the following terminology introduced in the Network Management
      Datastore Architecture <xref target="RFC8342"/>:
        <list style="symbols">
          <t>datastore schema</t>
        </list>
      </t>      
      <t>This document defines the following terminology:
        <list style="symbols">
	  <t>YANG schema: The combined set of schema nodes for a set of YANG module revisions,
	  taking into consideration any deviations and enabled features.</t>
	  <t>versioned schema: A YANG schema with an associated YANG semantic version number, e.g.,
	  as might be described by a YANG package<xref target="I-D.rwilton-netmod-yang-packages"/>.</t>
	  <t>schema-set: A set of related versioned YANG schema, one for each datastore that is
	  supported.</t>
        </list>
      </t>
      <t>TODO - 'YANG schema' and 'versioned schema' could be defined in the
      packages draft.</t>
    </section>
    <section anchor="intro" title="Introduction">
      <t>This document describes how NETCONF and RESTCONF clients can use protocol extensions, along
      with a version selection YANG module, to choose particular YANG schema for interactions with a
      server.</t>

      <t><xref target="I-D.verdt-netmod-yang-versioning-reqs"/> defines requirements that any
      solution to YANG versioning must have.</t>

      <t>YANG Semver <xref target="I-D.verdt-netmod-yang-semver"/>, based on YANG Module Versioning,
      specifies a partial solution to the YANG versioning requirements that focuses on using
      semantic versioning within individual YANG modules, but does not address all requirements
      listed in the YANG versioning requirements document.  Of particular relevance here,
      requirements 3.1 and 3.2 are not addressed.</t>

      <t>YANG Packages describes how sets of related YANG module revisions can be grouped together
      into a logical entity that defines a YANG schema.  Different packages can be defined for
      different sets of YANG modules, e.g., packages could be defined for the IETF YANG modules,
      OpenConfig YANG modules, or a vendor's YANG modules.  Different versions of these package
      definitions can be defined as the contents of these packages evolve over time, and as new
      revisions of the YANG modules included in the package are created.</t>

      <t>This document defines how YANG packages are used to represent versioned datastore schema,
      and how clients can choose which versioned schemas to use during protocol interactions with a
      device.</t>
    </section>
    <section anchor="background" title="Background">
      <t>There are three ways that the lifecycle of a data model can be managed:
      <list style="numbers">
	<t>Disallow all non-backwards-compatible updates to a YANG module.  Broadly this is the
	approach adopted by <xref target="RFC7950"/>, but it has been shown to be too inflexible in
	some cases.  E.g. it makes it hard to fix bugs in a clean fashion - it is not clear that
	allowing two independent data nodes (one deprecated, one current) to configure the same
	underlying property is robustly backwards compatible in all scenarios, particularly if the
	value space and/or default values differ between the module revisions.</t>

	<t>Allow non-backwards-compatible updates to YANG modules, and use a mechanism such as
	semantic version numbers to communicate the likely impact of any changes to module users,
	but require that clients handle non-backwards-compatible changes in servers by migrating to
	new versions of the modules.  Without version selection, this is what the YANG Semver
	approach likely achieves.</t>

	<t>Allow non-backwards-compatible updates to YANG modules, but also provide mechanisms to
	allow servers to support multiple versions of YANG modules, and provide clients with some
	ability to select which versions of YANG modules they wish to interact with, subject to some
	reasonable constraints.  This is the approach that this document aims to address.  It is
	worth noting that the idea of supporting multiple versions of an API is not new in the wider
	software industry, and there any many examples of where this approach has been used
	successfully.</t>
      </list>
      </t>
    </section>
    
    <section anchor="objectives" title="Objectives">
      <t>The goals of YANG schema selection are:
      <list style="symbols">
	<t>To provide a mechanism where non-backwards-compatible changes and bug fixes can be made
	to YANG modules without forcing clients to immediately migrate to new versions of those
	modules as they get implemented.</t>

	<t>To allow servers to support multiple versions of a particular YANG schema, and to allow
	clients to choose which YANG schema version to use when interoperating with the server.  The
	aim here is to give operators more flexibility as to when they update their management
	clients.</t>

	<t>To provide a mechanism to allow different YANG schema families (e.g., SDO models,
	OpenConfig models, Vendor models) to be supported by a server, and to allow clients to
	choose which YANG schema family is used to interoperate with the server.</t>

        <t>To closely align with existing NETCONF/RESTCONF protocol semantics.  I.e., with the
        exception of the new mechanisms required to select the schema-set at the beginning of
        NETCONF session or RESTCONF request, protocol interactions between client and server are the
        same as when schema selection is not being used.</t>

        <t>To allow considerable freedom for server implementations to decide how to implement
        schema selection, and choose the schema selection capabilities they support.  In particular:
        <list>
          <t>Servers determine which schema-sets can be selected by clients, and which combinations
          of schema-sets are compatible with each other during concurrent sessions/operations.</t>
          <t>Servers can make some schema-sets automatically available for client selection, or
          require clients to configure the selectable schema-sets before they can be used.</t>
          <t>Servers can limit clients to selecting only a single schema for all client connections,
          i.e., replacing the devices default schema-set, or allow clients to use different schema
          for concurrent sessions/operations.</t>
          <t>Servers can restrict some read-write datastore schema to be read-only in a schema-set.</t>
          <t>Servers may allow clients to combine schema-sets into named custom schema-sets, or only
          support predefined schema-sets.</t>
        </list>
        </t>
      </list>
      </t>

      <t>The following points are non objectives of this document:
      <list style="symbols">
	<t>This document does not provide a mechanism to allow clients to choose arbitrary sets of YANG
	module versions to interoperate with the server.</t>
	
        <t>Servers are not required to concurrently support clients using different YANG schema families
        or versioned schema.  A server MAY choose to only allow a single schema family or single
        versioned schema to be used by all clients.</t>

	<t>There is no requirement for a server to support every published version of a YANG
	package, particularly if some package versions are backwards compatible.  Clients are
	required to interoperate with backwards compatible updates of YANG modules.  E.g., if a
	particular package was available in versions 1.0.0, 1.1.0, 1.2.0, 2.0.0, 3.0.0 and 3.1.0,
	then a server may choose to only support versions 1.2.0, 2.0.0, and 3.1.0, with the
	knowledge that all clients should be able to interoperate with the server.</t>

	<t>There is no requirement to support all parts of all versioned schemas.  For some nbc
	changes in modules, it is not possible for a server to support both the old and new module
	versions, and to convert between the two.  Where appropriate, deviations SHOULD be used, and
	otherwise an out of band mechanism SHOULD be used to indicate where a mapping has
	failed.</t>
      </list>
      </t>
    </section>

    <section anchor="overview" title="Solution">
      <t>An outline of the solution is as follows:
        <list style="numbers">
	  <t>YANG packages are used to define versioned schema that represent a partial or full
	  schema for one or more datastores.</t>
          <t>Schema-sets are named structures that define a set of supported datastores, along with
          the schema associated with each of those datastores, specified via leaf references to YANG
          packages.</t>
          <t>The configurable 'selectable' leaf-list defines which schema-sets may be selected by
          clients, and the associated configurable 'default' leaf defines the default schema-set,
          used by clients do not select a schema-set.</t>
          <t>Clients choose which selectable schema-set to use via NETCONF capability exchange
          during session initiation, or RESTCONF path.</t>
          <t>Optionally, the configurable 'custom-schema-set' list allows clients to combine
          schema-sets together into new named schema-sets for selection.</t>
          <t>The 'change-selectable-schema' RPC allows clients to change the 'seletable' leaf-list,
          'default' leaf, and provide a replacement configuration in a single operation.</t>
          </list>
      </t>

      <section anchor="packages" title="Packages">
        <t>Section 5.3 of YANG Packages specifies how packages SHOULD be used to represent datastore schema.</t>
	<t>Additional guidance on how YANG packages are specified for version selection are:
	<list style="symbols">
	  <t>Separate packages MAY be defined for different families of schema, e.g., SDO,
	  OpenConfig, or vendor native.</t>
	  <t>Separate packages MAY be defined for each versioned schema within a schema family.</t>
          <t>All packages referenced for schema selection, and any recursive included package
          dependencies, MUST be available on the server in the '/packages' container in the
          operational state datastore.</t>
          <t>Globally scoped packages used for schema selection SHOULD be made available offline in
          YANG instance data documents.</t>
	</list></t>
      </section>

      <section anchor="schema-sets" title="Schema-sets">
        <t>A schema-set defines a set of datastore schema that could potentially be used for
        client schema selection.</t>
        <t>Each schema-set has a unique name that identifies the schema-set during schema selection
        protocol operations, e.g., it is used in both the NETCONF capabilities exchange and the RESTCONF
        path.</t>
        <t>A schema-set defines the set of supported datastores that are available when clients use
        the selected schema-set.  The schema for each datastore is specified as the union of one or more
        compatible YANG packages.  Writable datastores (e.g., running) can also be labelled as being
        read-only if they cannot be written to via client interactions using the schema-set.</t>
        <t>Not all schema-sets are necessarily compatible with each other, allowing one schema-set
        to be selected may prevent other schema-sets from being selected at the same time.  Hence,
        each schema-set lists the other schema-sets that it compatible with.</t>
        <t>The schema-sets supported by the server are available at
        '/ietf-schema-selection/schema-set' in the operational state datastore.</t>
        <t>TODO - It also makes sense for schema-sets to be made available offline in YANG
        instance-data documents.  The intention is that the ietf-schema-selection YANG module should
        be usable in a YANG instance data document.</t>
      </section>

      <section anchor="selectables" title="Defining and changing client selectable schema-sets">
        <t>A device may have to allocate resources to support selectable schema-sets, and the selectable
        leaf-list '/schema-set-selection/selectable' is the mechanism to constrain the set of
        schema-sets that can be selected by clients.</t>
        <t>In the operational state datastore, the 'selectable' leaf-list contains the names of all
        schema-sets that a client may select from.  Entries in this list MAY be added by the system
        without prior configuration.  In addition, the 'default' leaf indicates which schema-set is
        used by clients that do not explicitly select a schema.</t>
        <t>In configuration, the 'selectable' leaf-list allows clients to specify the schema-sets
        that a client may select from.  The client can also choose the default schema-set that is
        used if a client connects without naming a schema.</t>
      </section>

      <section anchor="protocol-ops" title="Schema selection protocol operations">
      <section anchor="netconf" title="NETCONF">
         <section anchor="newcap" title="schema-sets NETCONF capability">
            <t>A new NETCONF :schema-sets capability, using base:1.1 defined in <xref
            target="RFC6241"/></t>
            <t>This capability is used by the server is advertise selectable schema.  The server
            sends an comma separated list (with no white spaces) of selectable schema-sets it
            supports.  For consistency, the order of the entries in the list SHOULD match the order
            in the '/schema-set-selection/selectable' leaf-list.</t>
            <t>This capability is used by clients to select a particular schema.  The client sends
            an ordered list of selectable schema that it is willing to use.</t>
            <t>The selected schema is the first entry in the client schema-set list that is also
            contained in the server schema-set list.  If there is no common entry then the session
            is terminated with an error.</t>
            <t>If the client does not include the schema-set capability during the capability
            exchange then the default selectable schema-set is used.</t>            
            <t>The :schema-sets capability is identified by the following capability string:
            <list hangIndent="4" style="hanging">
               <t hangText="urn:ietf:params:netconf:capability:schema-sets:1.0"></t>
            </list>
            </t>
            <t>In this example, the server advertises its (abbreviated) &lt;hello&gt; as
               follows. This indicates that the server supports the following schema-sets:
               <list style="hanging">
                  <t hangText="example-ietf-routing:">Versions 2.1.0 and 1.3.1</t>
                  <t hangText="example-vendor-xxx:">Versions 9.2.3 and 8.4.2</t>
               </list>
                 
               Some extra white spaces have been added for display purposes only.
 
 <figure><artwork><![CDATA[
 <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
 <capabilities>
 <capability>urn:ietf:params:netconf:base:1.0</capability>
 <capability>urn:ietf:params:netconf:base:1.1</capability>
 <capability>
 urn:ietf:params:netconf:capability:schema-sets:1.0?list=
 example-ietf-routing@2.1.0,example-ietf-routing@1.3.1,
 example-vendor-xxx@9.2.3,example-vendor-xxx@8.4.2
 </capability> 
 </capabilities>
 </hello>
 
]]></artwork></figure>
            </t>
            <t>The client advertises its (abbreviated) &lt;hello&gt; as follows. This indicates the
            the client prefers to use the example-ietf-routing schema version 2.1.0, but can also
            use version 1.3.1.  Because both the client and server support version 2.1.0, and
            because the client listed it first, the selected schema-set is
            example-ietf-routing@2.1.0:
                 
               Some extra white spaces have been added for display purposes only.
 
 <figure><artwork><![CDATA[
 <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
 <capabilities>
 <capability>urn:ietf:params:netconf:base:1.1</capability>
 <capability>
 urn:ietf:params:netconf:capability:schema-sets:1.0?list=
 example-ietf-routing@2.1.0,example-ietf-routing@1.3.1
 </capability> 
 </capabilities>
 </hello>
 
]]></artwork></figure>
            </t>
         </section>
      </section>
      <section anchor="restconf" title="RESTCONF">
        <t>For RESTCONF, schema-sets are chosen via use of their name in the request path.</t>

        <t>Clients select the desired schema-set by choosing the corresponding RESTCONF root resource</t>
        <t>This updates Section 3.1 of <xref target="RFC8040"/>. For example, consider a device
        which has been configured with root-path "/restconf/example-ietf-routing-1.3.1" for
        secondary schema-set "example-ietf-routing-1.3.1". Any operations by the client on
        schema-set "example-ietf-routing-1.3.1" would use "/restconf/example-ietf-routing-1.3.1" as
        the RESTCONF root resource.</t>

        <t>TODO - Expand this explanation</t>
      </section>
    </section>
    <section anchor="custom_schema_sets" title="Custom schema-sets">
      <t>Custom schema-sets, if supported by the server, allow clients to:
      <list>
        <t>Configure client meaningful names for selectable schema-sets.</t>
        <t>Combine compatible schema-sets together into a combined named schema-set that is then
        selectable by clients.  E.g. a client might want to use a combination of standard
        configuration models along with vendor configuration models to manage functionality not
        covered by the standard models.</t>
      </list>
      </t>
    </section>
  </section>
  <section anchor="protocol" title="RPC protocol">
    <t>TODO - This section needs to be reworked for the updated RPC that only changes schema selection.</t>
         <section title="&lt;select-schema-sets&gt; operation">
            <t>Description: Used by a client to select schema-sets which 
               have been advertised by the server via the mechanism described above in <xref target="newcap"/>.
               The schema-sets are selected for the lifetime of the NETCONF session, unless
               new schema-sets are subsequently selected via this operation.</t>
            <t>Parameters:
            <list hangIndent="4" style="hanging">
               <t hangText="    schema-set:">Schema-set(s)that the client wants to use for this session.</t>
            </list>
            </t>
            <t>Positive response: if the server was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.</t>
            <t>Negative response: An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason. A &lt;select-schema-sets&gt; operation 
      can fail for a number of reasons, such as a YANG package version is not supported by the server, or a
      different version of a YANG package has already been selected by another client.</t>
            <t>Example: a client selects schema-sets example-ietf-routing version 1.3.1 and example-vendor-xxx version 9.2.3:
<figure><artwork><![CDATA[
     <rpc message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <select-schema-sets>
         <schema-sets>
           <schema-set>example-ietf-routing@1.3.1</schema-set>
           <schema-set>example-vendor-xxx@9.2.3</schema-set>
         </schema-sets>
       </select-schema-sets>
     </rpc>

     <rpc-reply message-id="101"
          xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <ok/> <!-- schema-set selection succeeded -->
     </rpc-reply>

]]></artwork></figure>                  
               </t>
               <t>TODO - add error indication</t>
         </section>
      </section>      
    <section title="Version selection from a server perspective">
    <t>The general premise of this solution is that servers generally implement one native schema,
    and the version selection scheme is used to support older version of that native schema and also
    foreign schema specified by external entities.</t>
    <t>Overall the solution relies on the ability to map instance data between different schema
    versions.  Depending on the scope of difference between the schema versions then some of these
    mappings may be very hard, or even impossible, to implement.  Hence, there is still a strong
    incentive to try and minimize nbc changes between schema versions to minimize the mapping
    complexity.</t>
    <t>Server implementations MUST serialize configuration requests across the different schema.
    The expectation is that this would be achieved by mapping all requests to the device's native
    schema version.</t>
    <t>Datastore validation MAY need to be performed in two places, firstly in whichever schema a
    client is interacting in, and secondly in the native schema for the device.  This could have a
    negative performance impact.</t>
    <t>Depending on the complexity of the mappings between schema versions, it may be necessary for
    the mappings to be stateful.</t>
    </section>
    <section title="Version selection from a client perspective">
      <t>Clients can use configuration to choose which schema-sets are
      available for selection.</t>
      <t>Clients cannot choose arbitrary individual YANG module versions, and are instead constrained
      by the versions that the server makes available via schema-sets.</t>
      <t>Each client protocol connection is to one particular schema-set.  From that client session
      perspective it appears as if the client is interacting with a regular server.  If the client
      queries YANG library that the version of YANG Library that is returned matches the schema-set
      that is being used for that server instance.</t>
      <t>The server may not support a schema with the exact version desired by the client, and they
      have to accept a later version that is backwards compatible with their desired version.
      Clients may also have to accept later schema versions that contain NBC fixes, although the
      assumption is that such nbc fixes should be designed to minimize the impact on clients.</t>
      <t>There is no guarantee that servers will always be able to support all older schema
      versions.  Deviations should be used where necessary to indicate that the server is unable to
      faithfully implement the older schema version.</t>
      <t>If clients interact with a server using multiple versions, they should not exact that all
      data nodes in later module versions can always be backported to older schema versions.  TODO -
      Specify how mapping errors can be reported to client.</t>
    </section>
    <section title="Limitations of the solution">
      <t>Not all schema conversions are possible.  E.g. an impossible type conversion, or something
      has been removed.  The solution is fundamentally limited by how the schemas actually change,
      this solution does not provide a magic bullet that can solve all versioning issues.</t>
    </section>
    <section title="Schema Version Selection YANG module">
      <t>The YANG schema version selection YANG module is used by a device to report the schema-sets
      that are available, and to allow clients to choose which schema-set they wish to use.</t>
      <t>Feature are used to allow servers to decide whether they allow the primary schema-set to be
      changed, and/or allow secondary schema-sets to be configured.</t>
      <t>The primary schema-set is the datastore schema reported by YANG Library.</t>
      <t>If secondary schema-sets are configured:
      <list>
         <t>With NETCONF, the "select-schema-sets" RPC is used by the client to chosse which schema-set(s) 
            it wants to use for the current NETCONF session.</t>
         <t>With RESTCONF, the configured root path prefix is used by the client for a particular 
            schema-set.</t>
      </list>
      </t>
      <t>Different schema-sets may support different datastores.</t>
      
      <figure>
        <preamble>The "ietf-schema-version-selection" YANG module has the following structure:</preamble>
        <artwork>
          <![CDATA[
module: ietf-schema-selection
  +--rw schema-set-selection!
     +--rw selectable*   -> /schema-set-selection/schema-set/name
     +--rw default       -> /schema-set-selection/selectable
     +--rw custom* [name] {custom-schema-set}?
     |  +--rw name               string
     |  +--rw description?       string
     |  +--rw included-schema*
     |          -> /schema-set-selection/schema-set/name
     +--ro schema-set* [name]
        +--ro name                 string
        +--ro partial?             empty
        +--ro datastore* [name]
        |  +--ro name         ds:datastore-ref
        |  +--ro read-only?   empty
        |  +--ro package* [name version]
        |     +--ro name        -> /pkgs:packages/package/name
        |     +--ro version     leafref
        |     +--ro checksum?   leafref
        +--ro compatible-with*
        |       -> /schema-set-selection/schema-set/name
        +--ro custom-selectable! {custom-schema-set}?
           +--ro combinable*
                   -> /schema-set-selection/schema-set/name

  rpcs:
    +---x change-selectable-schema
       +---w input
          +---w old
          |       -> /schema-set-selection/selectable
          +---w new
          |       -> /schema-set-selection/schema-set/name
          +---w make-default?               empty
          +---w (config)
             +--:(translate)
             |  +---w translate?            empty
             +--:(replacement-config)
                +---w replacement-config?   <anydata>
          ]]>
        </artwork>
      </figure>
    </section>

    <section title="YANG Module">
      <t>The YANG module definition for the module described in the previous sections.</t>
      <figure>
        <artwork>
          <![CDATA[
<CODE BEGINS> file "ietf-schema-version-selection@2019-11-29.yang"
module ietf-schema-selection {
  yang-version 1.1;
  namespace
    "urn:ietf:params:xml:ns:yang:ietf-schema-selection";
  prefix "schema";

  import ietf-yang-revisions {
    prefix rev;
    reference "XXXX: Updated YANG Module Revision Handling";
  }

  import ietf-datastores {
    prefix ds;
    rev:revision-or-derived 2018-02-14;
    reference
      "RFC 8342: Network Management Datastore Architecture (NMDA)";
  }

  import ietf-yang-packages {
    prefix pkgs;
    rev:revision-or-derived 0.2.0;
    reference "RFC XXX: YANG Packages.";
  }

  
  organization
    "IETF NETMOD (Network Modeling) Working Group";

  contact
    "WG Web:   <http://tools.ietf.org/wg/netmod/>
     WG List:  <mailto:netmod@ietf.org>

     Author:   Reshad Rahman
               <mailto:rrahman@cisco.com>

     Author:   Rob Wilton
               <mailto:rwilton@cisco.com>";

  description
    "This module provide a data model to advertise and allow the
     selection of schema versions by clients.

     Copyright (c) 2019 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX; see
     the RFC itself for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.";


  // RFC Ed.: update the date below with the date of RFC publication
  // and remove this note.
  // RFC Ed.: replace XXXX with actual RFC number and remove this
  // note.
  revision 2019-11-29 {
    description
      "Initial revision";
    reference
      "RFC XXXX: YANG Schema Version Selection";
  }

  /*
   * Features
   */
  feature "custom-schema-set" {
    description
      "Feature to choose whether clients may configurable custom
       schema definitions.";
  }

  /*
   * Top level data nodes.
   */
  
  container schema-set-selection {
    presence "Enable schema selection";
    
    description
      "YANG schema-set selection.

       Contains configuration and state related to client selectable
       YANG schema-sets.";
        
    leaf-list selectable {
      type leafref {
        path "/schema-set-selection/schema-set/name";
        require-instance false;
      }
      min-elements 1;
      
      description
        "Specifies the selectable schema used by this server, that
         can be selected by clients (either through NETCONF
         capability negotiation or RESTCONF schema specific path).";
    }

    leaf default {
      type leafref {
        path "/schema-set-selection/selectable";
      }
      mandatory true;
      description
        "Defines the default schema-set used by this server.

         This is the schema-set that is chosen if a NETCONF client
         doesn't select a schema during capability negotiation, or if
         the standard RESTCONF (or NMDA datastore URLs) are used.";
    }

    list custom {
      if-feature "custom-schema-set";
      key "name";
      
      description
        "Defines a custom selectable schema constructed from
         compatible schema";
      
      leaf name {
        type "string";
        description
          "Name of custom schema.

           Format can either be the form of a YANG identifer, or
           '<name>@<rev-label>'.

           The selectable-schema name is used in NETCONF capabilties
           negotiation and also the RESTCONF path (XXX, is encoding
           required, e.g. for '@'?)";
      }

      leaf description {
        type string;
        description
          "The description associated with this custom package.";
      }

      leaf-list included-schema {
        type leafref {
          path "/schema-set-selection/schema-set/name";
          require-instance false;
        }
        description
          "Lists the schema that are combined together into a single
           selectable schema (i.e. via a union operation on each
           datastore schema package).";
      }
    }
    
    list schema-set {
      key "name";
      config false;

      description
        "Lists all available schema-set's that can be used in schema
         version selection.";
      
      leaf name {
        type string;

        description
          "Name of the schema.

           Do we restrict what is allowed, specifically, do we allow
           '@'";
      }

      leaf partial {
        type empty;
        
        description
          "Indicates that this schema-set only represents a subset of
           the full configurable schema of the device.";
      }
            
      list datastore {
        key "name";

        description
          "The list of datastores supported for this pan-datastore
           selectable-package, along with the package schema
           associated with that datastore.";

        leaf name {
          type ds:datastore-ref;
          description
            "The datastore that this datastore schema is associated
             with.";
          reference
            "RFC 8342: Network Management Datastore Architecture
             (NMDA)";
        }

        leaf read-only {
          type empty;
          description
            "For datastores that are normally writable, the read-only
             flag indicates that the datastore cannot be written
             using this schema-set.  E.g., if <running> was a
             supported datastore then it could be read, but not
             written.

             This flag is not required for datastores, like
             operational, that are defined as being read-only.";
        }

        list package {
          key "name version";

          description
            "YANG packages that define the datastore schema

             The datastore schema is defined as the union of all
             datastore packages.";

          uses pkgs:yang-pkg-ref;
        }
      }

      leaf-list compatible-with {
        type leafref {
          path "/schema-set-selection/schema-set/name";
        }
        description
          "Lists other schema-sets that MAY be selected at the same
           time as this schema.";
      }

      container custom-selectable {
        if-feature "custom-schema-set";
        presence
          "This schema MAY be selected as part of a custom
           schema-set.";
        description
          "Indicates that this schema-set is selectable as part of a
           custom schema-set and also lists other schema-sets that
           may be combined together into a custom schema-set.";

        leaf-list combinable {
          type leafref {
            path "/schema-set-selection/schema-set/name";
          }
          description
            "Lists the schema-sets that MAY be combined with this
             schema into a single custom schema-set'.";
        }
      }
    }
  }

  /*
   * RPCs
   */
  
  rpc change-selectable-schema {
    description
      "RPC to allow a client to change the schema-set used by
       a server.";

    input {
      leaf old {
        type leafref {
          path "/schema-set-selection/selectable";
        }
        mandatory true;
        description
          "Selectable schema-set in use by this server.";
      }
      leaf new {
        type leafref {
          path "/schema-set-selection/schema-set/name";
        }
        mandatory true;
        description
          "Changes the schema-set used by this server.";
      }
      leaf make-default {
        type empty;

        description
          "Indicates that the schema-set should become the default
           schema-set used by the server.";
      }

      choice config {
        mandatory true;
        description
          "Specifies how the configuration is handled when the
           default schema is changed to the new schema-set.";
        
        leaf translate {
          type empty;
          description
            "Translate the existing configuration to the new
             schema-set, or fail the operation if this is not
             possible.";
        }

        anydata replacement-config {
          description
            "The configuration, in a form compatible with the new
             schema-set, that is used to replace the existing
             configuration, when it is changed to the new schema-set.
             The operational MUST be failed if this new configuration
             is not valid.";
        }
      }
    }
  }
}
<CODE ENDS>
]]>
        </artwork>
      </figure>
    </section>    
    
    <section anchor="security" title="Security Considerations">
      <t>To be defined.</t>
    </section>
    <section anchor="iana" title="IANA Considerations">
      <t>TODO - Add registrations for YANG modules defined in this document.</t>
      <t>This document registers a URI.</t>
      <section title="NETCONF Capability URNs">
         <t>This document registers a URI in the IETF XML
            registry <xref target="RFC3688"/>.  The IANA registry "Network Configuration
            Protocol (NETCONF) Capability URNs" needs to be updated to include
            the following capability.
 <figure><artwork><![CDATA[
   Index
       Capability Identifier
   -------------------------
   :schema-sets
       urn:ietf:params:netconf:capability:schema-sets:1.0 
]]></artwork></figure>

         </t>
      </section>
    </section>
    <section anchor="issues" title="Open Questions/Issues">
      <t>All issues, along with the draft text, are currently being
      tracked at: https://github.com/netmod-wg/yang-ver-dt/labels/version-selection-solution</t>
    </section>
    <section anchor="acknowledgements" title="Acknowledgements">
      <t>The ideas that formed this draft are based on discussions with the YANG versioning design
      team, and other members of the NETMOD WG.</t>
    </section>
  </middle>
  <?rfc needLines="20"?>
  <back>
    <references title="Normative References">
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.3688"?>
      <?rfc include="reference.RFC.5246"?>
      <?rfc include="reference.RFC.6241"?>
      <?rfc include="reference.RFC.6242"?>
      <?rfc include="reference.RFC.6536"?>
      <?rfc include="reference.RFC.7950"?>
      <?rfc include="reference.RFC.8040"?>
      <?rfc include="reference.RFC.8174"?>
      <?rfc include="reference.RFC.8342"?>
      <?rfc include="reference.I-D.verdt-netmod-yang-versioning-reqs"?>
      <?rfc include="reference.I-D.verdt-netmod-yang-module-versioning"?>
      <?rfc include="reference.I-D.verdt-netmod-yang-semver"?>
      <?rfc include="reference.I-D.rwilton-netmod-yang-packages"?>
      <?rfc include="reference.I-D.ietf-netconf-rfc7895bis"?>
      <?rfc include="reference.I-D.ietf-netmod-yang-instance-file-format"?>     
      <?rfc include="reference.I-D.ietf-netmod-module-tags"?>
    </references>
    <references title="Informative References">
      <?rfc include="reference.RFC.8199"?>
      <?rfc include="reference.I-D.bierman-netmod-yang-package"?>
      <?rfc include="reference.I-D.ietf-netmod-artwork-folding"?>
    </references>
    <?rfc needLines="100"?>
    <section title="Version selection examples">
      <t>Some common simplifications have been made to all of the examples:
      <list>
        <t>Only the packages and schema-selection subtrees are
        illustrated.  Other parts of '/yang-library' are omitted for
        brevity.</t>
        <t>Only minimal information is provided in the package
        definitions.</t>
        <t>Package and module checksums have been omitted to minimize
        line wrapping.</t>
      </list>
      </t>
      <section title="Supporting older versions of a schema">
        <t>To facilitate an easier migration path for clients, a server may choose to support older
        versions of a schema, for example this might be done to minimize impact on clients if
        non-backwards-compatible changes have been made between schema versions.</t>
        <t>It is expected that the server can dynamically translate from the older schema version to
        the latest, but this is not possible in all cases (e.g., if support for some functionality
        has been removed from the server), when deviations against the old schema version may be
        required to accurately describe the supported functionality.</t>
        <t>The example below illustrates a server that offers up two versions of the vendor's native
        schema, and allows the client to choose which version to use as the device default schema.
        The device defaults to the latest version of the schema, 'vendor-schema@2.1.0', but the
        client may configure the device to instead use an earlier version of the schema,
        'vendor-schema@1.4.5'.  Modifying the devices default schema means that this will be the
        schema version that all clients see, is the schema version used for persisted configuration
        (e.g., written to the startup datastore), and will be used for the datastore schema reported
        in YANG library.</t>
        <t>TODO - Insert instance data examples</t>
        <t>This example illustrates a device is that capable of supporting 3 different versions of its native manageability schema.
 - The clients can decide (via configuration or RPC) which version of schema should be supported by the device, and which version is default.</t>
<t>  
  Variantions:
  <list>
    <t>If the device could only support the clients interacting with a single verison of the schema,
    it could deviate "/schema-set-selection/selectable" to constrain the maximum number of elements
    to 1 (which must also be the default schema).</t>
    
    <t>If the device could only support clients configuring the device using a single schema
    version, but allow the configuration to be read back in later versions, then that can be
    acheived via having separate read-only and read-write versions of the schema-sets.  The
    "compatible-with" leaf-list could ensure that the necessary constraints are expressed in
    /schema-set-selection/schema-set/.</t>
  </list>
</t>
        <figure>
        <preamble></preamble>
        <artwork>
          <![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <data>
        <yang-library>
            <package>
                <name>vendor-schema</name>
                <version>3.0.0</version>
                <module>
                    <name>vendor-interfaces</name>
                    <revision>3.0.0</revision>
                </module>
                <module>
                    <name>vendor-routing-protocol</name>
                    <revision>2.0.0</revision>
                </module>
            </package>
            <package>
                <name>vendor-schema</name>
                <version>2.1.0</version>
                <module>
                    <name>vendor-interfaces</name>
                    <revision>3.0.0</revision>
                </module>
                <module>
                    <name>vendor-routing-protocol</name>
                    <revision>1.3.1</revision>
                </module>
            </package>
            <package>
                <name>vendor-schema</name>
                <version>1.4.5</version>
                <module>
                    <name>vendor-interfaces</name>
                    <revision>2.0.0</revision>
                </module>
                <module>
                    <name>vendor-routing-protocol</name>
                    <revision>1.2.1</revision>
                </module>
            </package>
        </yang-library>
        <schema-set-selection>
            <schema-set>
                <name>vendor-schema@3.0.0</name>
                <common-package>
                    <name>vendor-schema</name>
                    <version>3.0.0</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
                <compatible-with>vendor-schema@1.4.5</compatible-with>
                <compatible-with>vendor-schema@2.1.0</compatible-with>
            </schema-set>
            <schema-set>
                <name>vendor-schema@2.1.0</name>
                <common-package>
                    <name>vendor-schema</name>
                    <version>2.1.0</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
                <compatible-with>vendor-schema@1.4.5</compatible-with>
                <compatible-with>vendor-schema@3.0.0</compatible-with>
            </schema-set>
            <schema-set>
                <name>vendor-schema@1.4.5</name>
                <comon-package>
                    <name>vendor-schema</name>
                    <version>1.4.5</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
                <compatible-with>vendor-schema@2.1.0</compatible-with>
                <compatible-with>vendor-schema@3.0.0</compatible-with>
            </schema-set>
        </schema-set-selection>
    </data>
</rpc-reply>

Choosing/configuring the device default schema to run version 2.1.0 of the software.

<?xml version="1.0" encoding="utf-8"?>
<config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <schema-set-selection>
        <selectable>vendor-schema@1.4.5</selectable>
        <default>vendor-schema@1.4.5</default>
    </schema-set-selection>
</config>
]]>
        </artwork>
      </figure>

      </section>
      <section title="Supporting different schema families">
        <t>Some devices may allow clients to configure the device using
        different YANG schema (e.g. vendor native, vs IETF, vs
        OpenConfig).</t>
        <t>TODO - Expand description</t>
        <figure>
        <preamble></preamble>
        <artwork>
          <![CDATA[
Schema families, with custom schema
===================================

This example illustrates a device is that capable of supporting 3 different schema families (native, oc, ietf).

The clients may configure the device in three different ways:

(1) If the client wants to use a single schema family for all interactions with the device then they can choose a single schema-set and configure it as the default schema-set:

<?xml version="1.0" encoding="utf-8"?>
<config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <schema-set-selection>
        <selectable>oc-schema</selectable>
        <default>oc-schema</default>
    </schema-set-selection>
</config>


(2) If the clients wants to use multiple schema families, but restrict some interactions to a particular schema family, then they configure the default schema as "combined-schema", but also configure their desired secondary schema (any combination or "vendor-schema", "ietf-schema" or "oc-schema").

<?xml version="1.0" encoding="utf-8"?>
<config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <schema-set-selection>
        <selectable>combined-schema</selectable>
        <selectable>oc-schema</selectable>
        <default>combined-schema</default>
    </schema-set-selection>
</config>


(3) If there is a need for the client to use ietf or OC schema alongside the vendor schema, then this can be achieved by configuring a custom schema.  Two custom schema can be configured, either "vendor + ietf schema", or "vendor + oc schema".  Once the custom schema has been configured then it could be used either as the single default schema, or it could be used as a selectable schema with the default schema set to "combined-schema".

<?xml version="1.0" encoding="utf-8"?>
<config xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <schema-set-selection>
        <custom>
            <name>my-custom-schema</name>
            <description>Restrict the primary schema to OC and vendor</description>
            <included-schema>vendor-schema</included-schema>
            <included-schema>oc-schema</included-schema>
        </custom>
        <selectable>my-custom-schema</selectable>
        <default>my-custom-schema</default>
    </schema-set-selection>
</config>


Note, for the last case, rather than requiring the client to configure custom schema, the device could predefine "vendor + ietf" and "vendor + oc" schema-sets.

<?xml version="1.0" encoding="utf-8"?>
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <data>
        <yang-library>
            <package>
                <name>vendor-schema</name>
                <version>1.0.0</version>
                <module>
                    <name>vendor-interfaces</name>
                    <!--Module list of vendor YANG modules elided for brevity -->
                </module>
            </package>
            <package>
                <name>ietf-schema</name>
                <version>1.0.0</version>
                <module>
                    <name>ietf-interfaces</name>
                    <!--Module list of IETF YANG modules elided for brevity -->
                </module>
            </package>
            <package>
                <name>oc-schema</name>
                <version>1.0.0</version>
                <module>
                    <name>openconfig-interfaces</nmae>
                    <!--Module list of OpenConfig YANG modules elided for brevity -->
                </module>
            </package>
        </yang-library>
        <schema-set-selection>
            <schema-set>
                <name>full-schema</name>
                <common-package>
                    <name>vendor-schema</name>
                    <version>1.0.0</version>
                </common-package>
                <common-package>
                    <name>ietf-schema</name>
                    <version>1.0.0</version>
                </common-package>
                <common-package>
                    <name>oc-schema</name>
                    <version>1.0.0</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
            </schema-set>
            <schema-set>
                <name>vendor-schema</name>
                <partial/>
                <common-package>
                    <name>vendor-schema</name>
                    <version>1.0.0</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
                <compatible-with>combined-schema</compatible-with>
                <compatible-with>ietf-schema</compatible-with>
                <compatible-with>oc-schema</compatible-with>
                <custom-selectable>
                    <combinable>ietf-schema</combinable>
                    <combinable>oc-schema</combinable>
                </custom-selectable>
            </schema-set>
            <schema-set>
                <name>ietf-schema</name>
                <partial/>
                <common-package>
                    <name>ietf-schema</name>
                    <version>1.0.0</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
                <compatible-with>combined-schema</compatible-with>
                <compatible-with>vendor-schema</compatible-with>
                <compatible-with>oc-schema</compatible-with>
                <custom-selectable>
                    <combinable>vendor-schema</combinable>
                </custom-selectable>
            </schema-set>
            <schema-set>
                <name>oc-schema</name>
                <partial/>
                <common-package>
                    <name>oc-schema</name>
                    <version>1.0.0</version>
                </common-package>
                <datastore>
                    <name>ds:running</name>
                </datastore>
                <datastore>
                    <name>ds:operational</name>
                </datastore>
                <compatible-with>combined-schema</compatible-with>
                <compatible-with>vendor-schema</compatible-with>
                <compatible-with>ietf-schema</compatible-with>
                <custom-selectable>
                    <combinable>vendor-schema</combinable>
                </custom-selectable>
            </schema-set>
        </schema-set-selection>
    </data>
</rpc-reply>]]>
        </artwork>
      </figure>
    </section>
    </section>
  </back>
</rfc>

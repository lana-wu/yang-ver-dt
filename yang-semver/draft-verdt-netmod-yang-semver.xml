<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC6020 SYSTEM "reference.RFC.6020.xml">
<!ENTITY RFC7895 SYSTEM "reference.RFC.7895.xml">
<!ENTITY RFC7950 SYSTEM "reference.RFC.7950.xml">
<!ENTITY OPENCONFIG-YANG-CATALOG SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.openconfig-netmod-model-catalog.xml">
<!ENTITY CLAISE-SEMVER "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.claise-semver.xml">
<!ENTITY CLAISE-SEMVER "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.netconf-rfc7895bis">
<!ENTITY OPENCONFIG-YANG-CATALOG SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.openconfig-netmod-model-catalog.xml">
<!ENTITY CLACLA-NETMOD-MODEL-CATALOG "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.clacla-netmod-model-catalog.xml">
<!ENTITY VERDT-NETMOD-YANG-VERSIONING-REQS "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.verdt-netmod-yang-versioning-reqs.xml">
]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc updates="7950" category="std" ipr="trust200902" docName="draft-verdt-netmod-yang-semver-00">
<front>
<title abbrev="YANG Catalog">New YANG Module Update Procedure</title>

<author initials="B." surname="Claise" fullname="Benoit Claise">
  <organization abbrev="Cisco Systems, Inc.">
    Cisco Systems, Inc.
 </organization>
  <address>
    <postal>
<street>De Kleetlaan 6a b1</street>
<city>1831 Diegem</city>
<country>Belgium</country>
    </postal>
    <phone>+32 2 704 5622</phone>
    <email>bclaise@cisco.com</email>
  </address>
</author>

  <author initials="J." surname="Clarke" fullname="Joe Clarke">
    <organization>Cisco Systems, Inc.</organization>
    <address>
      <postal>
        <street>7200-12 Kit Creek Rd</street>
        <city>Research Triangle Park</city>
        <region>North Carolina</region>
        <country>United States of America</country>
      </postal>
      <phone>+1-919-392-2867</phone>
      <email>jclarke@cisco.com</email>
    </address>
  </author>

  <author initials="B." surname="Lengyel" fullname="Balazs Lengyel">
    <organization abbrev="Ericsson"> Ericsson </organization>
    <address>
      <postal>
        <street>Magyar Tudosok Korutja</street>
        <city>1117 Budapest</city>
        <country>Hungary</country>
      </postal>
      <phone>+36-70-330-7909</phone>
      <email>balazs.lengyel@ericsson.com</email>
    </address>
  </author>

<author initials="K." surname="D'Souza" fullname="Kevin D'Souza">
  <organization>AT&amp;T</organization>
  <address>
    <postal>
<street>200 S. Laurel Ave</street>
<city>Middletown</city>
<region>NJ</region>
<country>United States of America</country>
    </postal>
    <phone></phone>
    <email>kd6913@att.com</email>
  </address>
</author>

<date/>
<abstract>
  <t>
  This document specifies a new YANG module update procedure in case of non-backwards-compatible
  changes, as an alternative proposal to the YANG 1.1 specifications. This document updates RFC 7950.
  </t>
</abstract>
</front>
<middle>
<section anchor="intro" title="Introduction">
<t>This document puts forth a solution to the problems described in <xref target="I-D.verdt-netmod-yang-versioning-reqs"/>
 by proposing changes to <xref target="RFC7950"/> to address the various requirements that <xref target="I-D.verdt-netmod-yang-versioning-reqs"/> specifies.
At this time, the solution herein addresses requirements 1.1, 1.2, 1.3, 2.1, 4.1, 4.2, 4.3, 5.1, and 5.2.  Current gaps are documented in
<xref target="open_issues_reqs"/> below.</t>
</section>
<section anchor="the_solution" title="The Solution">
  <t>
  The solution is composed of five parts:
       <list style="numbers">
       <t>A semantic versioning YANG extension, along with an optional additional check that validates
	      the semantic versioning from a syntactic point of view, which can either assist in
		  determining the correct semantic versioning value, or which can help in determining
		  the values for YANG modules that do not support this extension. </t>
       <t>An import by semantic version statement</t>
       <t>Updates to the YANG 1.1 module update rules</t>
	     <t>Updates to ietf-yang-library</t>
       <t>An introduction of deprecated and obsolote reason clauses</t>
     </list>
  </t>
</section>

  <section anchor="changes_7950" title="Changes to RFC7950">
    <t>
      The sections listed below provide updates to <xref target="RFC7950"/>.  However, the design team does not believe
      any of the will require a new version of the YANG language.  It is believed that the extensions as they are defined
      can coexist with existing YANG 1.1 clients.
    <list style="symbols">
      <t><xref target="update_rules"/> which describes modification to the <xref target="RFC7950"/> Section 11
        module update text to advise the use of semantic versioning as described in this document</t>
      <t><xref target="import_semver"/> which describes an extension to do import by semantic version</t>
      <t><xref target="deprecated_and_obsolete_reasons"/> defines an extension that adds a child element to
        "status"</t>
    </list>
  </t>
  </section>

<section anchor="semantic_versioning" title="YANG Semantic Versioning">
  <t>The first part of the solution introduces and defines YANG Semantic
  Versioning, explains how it is used with YANG modules, and the rules
  associated with changing a module's semantic version number when the
  module definitions are updated.</t>

  <t>This part of the solution addresses requirements 1.1, 1.2, and 2.1
  of <xref target="I-D.verdt-netmod-yang-versioning-reqs"/>.</t>

  <t>The YANG semantic versioning scheme applies only to YANG modules.
  YANG submodules are not independently versioned by the YANG semantic
  versioning scheme.  Instead, if a versioned module includes one or
  more submodules then those submodules are implicitly versioned as part
  of the module's 'semver:version' statement, and all 'include'
  statements MUST specify the revision-date for each of the included
  submodules.</t>


  <section anchor="version_classification" title="Classification of changes between module revisions">
    <t>The principle aim of YANG semantic versioning is to allow a
    reader of a module to understand the overall significance of any
    changes between two module revisions solely based on the semantic
    version number.</t>
    
    <t>The semantic version change between any two artibrary revisions
    of a YANG module can be classified into one of four categories:
    'unchanged', 'editorial, 'backwards-compatible' or
    'non-backwards-compatible'.  The classification is performed by
    use of the following rules:
    <list style="bullets">
      <t>The semantic version change between two modules revisions is
      defined as 'unchanged' if, after excluding 'revision' and
      'semver:version' statements and their substatements, the only
      remaining changes are insignificant white space changes.</t>
      
      <t>An 'editorial' module semantic version change is where there
      are changes in the module's statements, or statement ordering,
      between the two module revisions, but thoses changes do not affect
      the syntax or semantic meaning of the module in any way.  An
      example of an editorial change would be a fix to a spelling
      mistake in a description statement.</t>

      <t>A 'backwards-compatible' module semantic version change is
      where some syntax or semantic changes exists between the two
      module revisions, but all changes follow the rules of "Updating a
      Module" of [RFC7950], except that no elements have been changed to
      status 'obsolete', and re-ordering of statements is allowed.</t>

      <t>A 'non-backwards-compatible' module semantic version change is
      where some syntax or semantic changes exists between the two
      module revisions, and those changes do not follow the rules of
      "Updating a Module", or one or more schema nodes have been changed
      to status 'obsolete'.</t>
    </list>
    </t>

    <t>Q: Should revision-date history and semantic version be excluded
    from the comparision? RW: I've assumed yes.</t>

    <t>Q. Does statement ordering need to be considered as part of the
    comparision? RW: I think the answer should be no. RR: ordering matters for RPC/action input as per https://tools.ietf.org/html/rfc7950#section-7.5.7</t>
  </section>

       
  <section anchor="versioning_scheme" title="YANG Semantic Versioning Scheme for Modules">
    <t>This document defines the YANG semantic versioning scheme that is used for YANG
    modules. The versioning scheme has the following properties:
    <list style="bullets">
      <t>The YANG semantic versioning scheme is extended from version
      2.0.0 of the semantic versioning scheme defined at semver.org <xref
      target="semver"/> to cover the additional requirements for the
      management of YANG module lifecyles that cannot be addressed using
      the semver.org 2.0.0 versioning scheme alone.</t>
      
      <t>Unlike the semver.org 2.0.0 versioning scheme, the YANG
      semantic versioning scheme supports limited updates to older
      versions of YANG modules, to allow for bug fixes and enhancements
      to module versions that are not the latest.</t>
      
      <t>Module definitions that follow the semver.org 2.0.0 versioning
      scheme are fully compatible with implementations that understand
      the YANG semantic versioning scheme.</t>

      <t>If module updates are always restricted to the latest version
      of the module only, then the version numbers used by the YANG
      semantic versioning scheme are exactly the same as those defined
      by the semver.org 2.0.0 versioning scheme.</t>
    </list>
    </t>
    <t>Every YANG module SHOULD include a top-level 'semver:version'
    statement that specifies the YANG semantic version number for each
    revision of the module.</t>

    <t>All 'revision' statements in YANG modules SHOULD include a
    'semver:version' substatement that specifies the YANG semantic
    version number associated with that particular revision of the
    module.</t>

    <t>
     "The YANG semver version number is expressed as a string of the
     form: 'X.Y.Zv'; where X, Y, and Z each represent non-negative
     integers smaller than 32768, and v represents an optional single
     character suffix: 'm' or 'M'.
     
     <list style="symbols">
       <t>'X' is the MAJOR version.  Changes in the major version number
       indicate changes that are non-backwards-compatible to versions
       with a lower major version number.</t>

       <t>'Y' is the MINOR version.  Changes in the minor version number
       indicate changes that are backwards-compatible to versions with
       the same major version number, but a lower minor version
       number.</t>

       <t>'Zv' is the PATCH version and modifier.  Changes in the patch
       version number can indicate editorial, backwards-compatible, or
       non-backwards-compatible changes relative to versions with the
       same major and minor version numbers, but lower patch version
       number, depending on what form modifier 'v' takes:
       <list style="symbols">
	 <t>'M' - the change represents a non-backwards-compatible change</t>
	 <t>'m' - the change represents a backwards-compatible change</t>
	 <t>If the modifier letter is absent, the change represents an
	 editorial change</t>
       </list>
       </t>
     </list>
    </t>
  </section>
  
  <section anchor="semver_update_rules" title="YANG Semantic Version Update Rules">
    <t>When a new revision of a module is produced, then the following
    rules define how the YANG semantic version number for the new module
    revision is calculated, based on the changes between the two module
    revisions, and the YANG semantic version number of the base module
    revision that the changes are derived from.  A two step process is
    used:</t>

    <t>The first step is to classify the module change as 'editorial',
    'backwards-compatible', or 'non-backwards-compatible version' using
    the rules defined in <xref target="version_classification"/>.</t>

    <t>The second step is to calculate the value of the 'semver:version'
    field for the new module revision, based on the value of the
    'semver:version' field in the base module, any how the module
    changes have been classified.</t>

    <t>The following rules define how the value for the 'semver:version'
    argument in the new module revision is calculated:
    <list>
      <t>If the module is being updated in a non-backwards-compatible
      way, then the module version "X.Y.Z[m|M]" SHOULD be updated to
      "X+1.0.0" unless that module version has already been defined with
      different content, in which case the module version "X.Y.Z+1M MUST
      be used instead.</t>

      <t>If the module is being updated in a backwards-compatible way,
      then the module version "X.Y.Z[m|M]" SHOULD be updated to
      "X.Y+1.0" unless that module version has already been defined with
      different content, in which case if the current module version is
      "X.Y.ZM" then it MUST be updated to "X.Y.Z+1M", or otherwise
      "X.Y.Z+1m".</t>

      <t>If the module is being updated in an editorial way, then the
      module version "X.Y.Z[m|M]" MUST be updated to "X.Y.Z+1[m|M],
      retaining the 'm|M' character if it is already present in the
      previous version.".</t>

      <t>YANG module semantic version numbers begining with 0, i.e
      "0.X.Y" are regarded as beta definitions and need not follow the
      nbc rules above, and the minor version number can be incremented
      instead.</t>

      <t>In all cases, the 3 numeric fields that comprise a YANG module
      semantic version number associated with a YANG module MUST
      uniquely identify the contents of that YANG module.  E.g., module
      version "1.2.3M" is not allowed if module version "1.2.3" has
      already been defined.</t>
    </list>
    </t>
  </section>
  <section anchor="semver_extension" title="YANG Module Semver Extension">
    <t>This document defines a YANG extension to add the YANG module
    semantic version to a Module.  The complete definition of this YANG
    module is in section XXX.
    </t>

    <figure>
      <artwork>
        extension module-version {
            argument semver;
        }
      </artwork>
    </figure>
    <t>
    The extension would typically be used this way:
    </t>
    <figure>
       <artwork>
    module yang-module-name {

      namespace "name-space";
      prefix "prefix-name";

      import ietf-semver { prefix "semver"; }
      
      description
        "to be completed";

      semver:module-version "2.0.0";

      revision 2017-10-30 {
        description
          "Change the module structure";
        semver:module-version "2.0.0";
      }

      revision 2017-07-30 {
        description
          "Added new feature XXX";
        semver:module-version "1.2.0";
      }

      revision 2017-04-03 {
        description
          "Update copyright notice.";
        semver:module-version "1.0.1";
      }

      revision 2017-04-03 {
        description
          "First release version.";
        semver:module-version "1.0.0";
      }

      revision 2017-01-26 {
        description
          "Initial module for inet types";
        semver:module-version "0.1.0";
      }

      //YANG module definition starts here
       </artwork>
    </figure>

	<t>
    See also "Semantic Versioning and Structure for IETF Specifications" <xref target="I-D.claise-semver"/> for a mechanism
    to combine the semantic versioning, the GitHub tools, and a potential change to the IETF process.
    </t>
  </section>
</section>

<section title="Import by Semantic Version" anchor="import_semver">
  <t>RFC 7950 allows YANG module 'import' statements to optionally
  require the imported module to have a particular revision date.  In
  practice, importing a module with an exact revision date is overly
  burdensome because it requires the importing module to be updated
  whenever any change to the imported module occurs.  The alternative
  choice of using an import statement without a revision date is also
  not ideal because the importing module may not work with all possible
  revisions of the imported module.</t>

  <t>With semantic versioning, it is desirable for a importing module to
  specify the set of module versions of the imported module that are
  anticipated to be compatible.</t>
  
  <t>This document specifies a YANG extension for selecting which
  versions of a module may be imported.  It is designed around the
  assumption that most changes to a YANG module do not break importing
  modules, even if the changes themselves are not backwards compatible.
  E.g., fixing an incorrect pattern statement or description for a leaf
  would not break an import, changing the name of a leaf could break an
  import but frequently would not, but removing a container would break
  imports if it is augmented.</t>

  <t>The ietf-semver module defines the 'version' extension, a
  substatement to the YANG 'import' statement.  An 'import' statement
  may contain 'version' statements or a 'revision-date' statement, but
  not both.  The 'version' statement may be specified multiple times,
  requiring that the imported module version conforms to at least one of
  the 'version' statements.</t>

  <t>The argument to the 'version' statement takes one of three valid forms:
  <list style="numbers">
  <t>"A.B.C" - import the exact module version that matches "A.B.C".</t>
  <t>"A.B.C+" - import any module version that matches, or is
  greater than, "A.B.C".</t>
  <t>"A.B.C-X.Y.Z" - import any module version that matches, or is
  greater than, "A.B.C"; and also matches, or is less than, "X.Y.Z".
  The word "MAX" can be used for 'Y' or 'Z' to represent the numerical
  value 32,767.</t>
  </list>
  </t>
  <t>The rules for comparing module version numbers are as follows:
  <list style="numbers">
    <t>Version "R.S.T" matches version "A.B.C", only if
    <list style="none">
      <t>R = A, S = B, and T = C</t>
    </list>
    </t>

    <t>Version "R.S.T" is greater than version "A.B.C", only if
    <list style="none">
      <t>R = A, S = B, and T > C; or</t>
      <t>R = A and S > B; or</t>
      <t>R > A</t>
    </list>
    </t>

    <t>Version "R.S.T" is less than version "X.Y.Z", only if
    <list style="none">
      <t>R = X, S = Y, and T &lt; Z; or</t>
      <t>R = X and S &lt; Y; or</t>
      <t>R &lt; X</t>
    </list>
    </t>
  </list>
  </t>
  <section title="Module import examples">
      <t>Consider an example module "example-module" that is
      hypothetically available in the following versions: 0.1.0, 1.0.0,
      1.1.0, 1.1.1m, 1.1.2M, 1.1.3M, 1.2.0, 2.0.0, 3.0.0.</t>

      <t>The first example selects the specific version 1.1.2M.  A
      specific version import might be used if 1.1.2M contained changes
      that are incompatible with other versions.</t>
      <figure>
        <artwork>
import example-module {
  semver:version 1.1.2;
}
	</artwork>
      </figure>

      <t>The next example selects module versions that match, or are
      greater than, version 1.1.0.  This form may be used if there is a
      dependency on a data node introduced in version 1.1.0.  This is
      expected to be the most commonly used form of 'import by version'.</t>
      <t>Includes versions: 1.1.0, 1.1.1m, 1.1.2M, 1.1.3M,
      1.2.0, 2.0.0 and 3.0.0.</t>
      <figure>
        <artwork>
import example-module {
  semver:version 1.1.0+;
}
	</artwork>
      </figure>

      <t>The next example selects module versions that match, or are
      greater than 1.1.0, but excluding the 1.1.2M and 1.1.3M versions.
      This form may be needed if structural non backwards compatible
      changes are introduced in a patch 'M' version.  Generally, it is
      advisable to avoid making such changes.</t>
      <t>Includes versions: 1.0.0, 1.1.0, 1.1.1m, 1.2.0, 2.0.0 and
      3.0.0.</t>
      <figure>
        <artwork>
import example-module {
  semver:version 1.0.0-1.1.1;
  semver:version 1.2.0+;
}
	</artwork>
      </figure>

      <t>The last example selects all module versions with a major
      version number of 1.  This form may be useful if significant non
      backwards compatible changes have been introduced in version 2.0.0
      that break import backwards compatibility.</t>
      <t>Includes versions: 1.0.0, 1.1.0, 1.1.1m, 1.1.2M, 1.1.3M,
      1.2.0.</t>
      <figure>
        <artwork>
import example-module {
  semver:version 1.0.0-1.MAX.MAX;
}
	</artwork>
      </figure>
  </section>
  <section title="TODO">
       <t>
       TODO - Add text like this to the guidelines.  The import
       statement SHOULD include a semver:import-versions statement and
       MUST NOT include a revision statement.  An import statement MUST
       NOT contain both a semver:import-versions and a revision
       substatement.  The use of the revision substatement for import
       should be discouraged.
      </t>
    <t>TODO - Perhaps guidance text should also warn about making nbc
    changes that could break imports.  E.g. this could be an example of
    where making something obsolete might be better than removing
    it.</t>
  </section>
</section>

  <section title="Updates to YANG 1.1 Module Update Rules" anchor="update_rules">
      <t>
          RFC 7950 section 11, must be updated to allow for non-backward changes provided they follow the
          semantic versioning guidelines and increase the MAJOR version number when a backward incompatible
          change is made.  This change is in the spirit of requirement 5.1 from <xref target="I-D.verdt-netmod-yang-versioning-reqs"/>.
          The following is proposed text for this change.</t>

      <t>
      "As experience is gained with a module, it may be desirable to revise that module.
      Changes to published modules are allowed, even if they have some potential to cause interoperability
      problems, if the module-version YANG extension is used in the revision statement to clearly indicate the nature of the change."
      </t>
  </section>

  <section title="Updates to ietf-yang-library" anchor="ietf_yang_library_updates">
      <t>The ietf-semver YANG module also specifies additional ietf-yang-library <xref target="RFC7895"/>
	    <xref target="I-D.ietf-netconf-rfc7895bis"/> leafs to be
        added at the module and submodule levels.  The first is module-version, which augments
        /yanglib:yang-library/yanglib:module-set/yanglib:module.  This specifies the current semantic version
        of the associated module and revision in a given module-set.  The related submodule-version leaf is added at
        /yanglib:yang-library/yanglib:module-set/yanglib:module/yanglib:submodule to indicate the semantic version of
        a submodule.</t>
      <t>In order to satisfy the requirements 4.1 and 4.3 of <xref target="I-D.verdt-netmod-yang-versioning-reqs"/> that deprecated and obsolete node presence and operation are easily and clearly
        known to clients, ietf-semver also augments the ietf-yang-library with two additional boolean leafs at
        /yanglib:yang-library/yanglib:module-set/yanglib:module.  A client can make one request of the ietf-yang-library and
        know whether or a not a module that has deprecated or obsolete has those nodes implemented by the server, as opposed to
        making multiple requests for each node in question.
        <list style="hanging">
          <t hangText="deprecated-nodes-present :">A boolean that indicates whether or not this server implements deprecated nodes.
           The value of this leaf SHOULD be true; and if so, the server MUST implement nodes
           within this module as they are documented.  If specific deprecated nodes are not
           implemented as documented, then they MUST be listed as deviations.  This leaf defaults to true.</t>
          <t hangText="obsolete-nodes-present :">A boolean that indicates whether or not this server implements obsolete nodes.
           The value of this leaf SHOULD be false; and if so, the server MUST NOT implement
           nodes within this module. If this leaf is true, then all nodes in this module MUST
           be implemented as documented in the module.  Any variation of this MUST be listed as
           deviations.  This leaf defaults to false.</t>
         </list>
       </t>
       <t>
         If a module does not have any deprecated or obsolete nodes, the server SHOULD set the corresponding leaf above
         to true.  This is helpful to clients, such that if the MAJOR version number has not changed, and these booleans are
         true, then a client does not have to check the status of any node for the module.
       </t>
       <t>Module compatibility can be affected if values other than the default are used for the leafs described here.
         For example, if a server does
         not implemennt deprecated nodes, then a given module revision may be incompatible with a previous revision where
         the nodes were not deprecated.  When calculating backward compatibility, the default values of these
         leafs MUST be considered.  From a client's point of view, if two module revisions have the same MAJOR version
         but the run-time value of deprecated-nodes-present (as read from the ietf-yang-library) is false, then
         compatibility MUST NOT be assumed based on the module-version alone.</t>
  </section>

  <section title="Deprecated and Obsolete Reasons" anchor="deprecated_and_obsolete_reasons">
    <t>The ietf-semver module specifies an extension, status-description, that is designed to be used as
      a substatement of the status statement when the status is deprecated or obsolete.  The argument to
      this extension is freeform text that explains why the node was deprecated or made obsolete.  It may also
      point to other schema elements that take the place of the deprecated or obsolete node.  This text
      is designed for human consumption to aid in the migration away from nodes that will one day no longer work.
      These extensions address requirement 4.2 of <xref target="I-D.verdt-netmod-yang-versioning-reqs"/>.
      An example is shown below.</t>

      <figure>
        <artwork>
leaf imperial-temperature {
  type int64;
  units "degrees Fahrenheit";
  status deprecated {
    semver:status-description
      "Imperial measurements are being phased out in favor
       of their metric equivalents.  Use metric-temperature
       instead.";
  }
  description
    "Temperature in degrees Fahrenheit.";
}
        </artwork>
      </figure>
    </section>

<section anchor="guidelines" title="Guidelines">
   <section anchor="guidelines_authors" title="Guidelines to YANG model authors">
      <section anchor="authors_semver" title="Use of semantic versioning">
      <t>Reuse of an already used module-version MUST be avoided. For example, when updating 3.4.0 in a NBC manner the module author must verify whether version 4.0.0 is available for use and if that version was already used, the updated module must use the version 3.4.1M.</t>
      <t>From a published revision N of a module, the next published revision N+1 of the module SHOULD
         have one of:
         <list style="numbers">
            <t>MAJOR version incremented by 1, MINOR and PATCH versions set to 0. This indicates that in revision N+1:
               <list style="symbols">
               <t>There have been one or more non-backwards-compatible changes</t>
               <t>There may also be new functionality which have been added in a backwards-compatible manner</t>
               <t>There may also be bug fixes which have been made in a backwards-compatible manner</t>
               </list></t>
            <t>MAJOR version unchanged, MINOR version incremented by 1 and PATCH version set to 0. This indicates that
               in revision N+1:
               <list style="symbols">
               <t>There are no non-backwards-compatible changes</t>
               <t>There have been one or more new functionality which have been added in a backwards compatible-manner</t>
               <t>There may also be bug fixes which have been made in a backwards-compatible manner</t>
               </list></t>
            <t>MAJOR and MINOR versions unchanged, PATCH version incremented by 1. This indicates that in revision N+1:
               <list style="symbols">
                  <t>There are no non-backwards-compatible changes</t>
                  <t>There is no new functionality which has been added in a backwards compatible-manner</t>
                  <t>Ther are 1 or more bug fixes which have been made in a backwards-compatible manner</t>
               </list></t>
         </list>
      </t>
      <t>As explained in <xref target="implementation_experience"/>, while programatically determining a semantic version is possible
         using the pyang utility, human overisght is highly recommended because of some special cases which can not be detected by pyang.
         Therefore, a model author SHOULD use both means to determine a model's semantic version.</t>
       </section>
       <section title="Making non-backwards-compatible changes to a YANG module">
       <t>There are various valid situations where a YANG module has to be modified in a non-backwards-compatible way. Here are some guidelines on how non-backwards compatible changes SHOULD be made:
          <list style ="numbers">
             <t>The changes should be made incrementally, e.g. a data node's status SHOULD NOT be changed directly from "current" to "obsolete" (see Section 4.7 of <xref target="RFC8407"/>), instead the status SHOULD first be marked "deprecated" and then when support is removed its status MUST be changed to "obsolete". Instead of using the "obsolete" status, the data node MAY be removed from the model but this has the risk of breaking modules which import the modified module.</t>
             <t>A node with status "deprecated" MUST be supported. Q: if we keep this, do we still need the deprecated-nodes-present leaf, see <xref target="ietf_yang_library_updates"/>.</t>
             <t>A node with status "deprecated" SHOULD be available for at least one year before its status is changed to "obsolete", see Section 4.7 of <xref target="RFC8407"/>.</t>
             <t>Support for a node which is "obsolete" is indicated by the node "obsolete-nodes-present, see <xref target="ietf_yang_library_updates"/>.</t>
             <t>The new extension "status-description" SHOULD be used for nodes which are "obsolete" or "deprecated".</t>
             <t>For status "deprecated", the "status-description" SHOULD also indicate until when support for the node is guaranteed. If there is a replacement data node, rpc, action or notification for the deprecated node, this MUST be stated in the "status-description".</t>
             <t>When obsoleting or deprecating data nodes, the "deprecated" or "obsolete" status SHOULD be applied at the highest possible level in the data tree. For example, when deprecating all data nodes in a container, the "deprecated" status SHOULD be applied to the container.</t>            
          </list>
          </t>
         <t>The following sections have examples on how non-backwards-compatible changes can be made.</t>

         <section anchor="remove_bode" title="Removing a data node">
            <t>Removing a leaf or container from the data tree, e.g. because support for the corresponding feature is being removed:
            <list style="numbers">
               <t>The node's status SHOULD be changed to "deprecated" and it MUST be supported for at least one year. This is a backwards-compatible change.</t>
               <t>When the node is not available anymore, its status MUST be changed to "obsolete" and the "status-description" updated, this is a non-backwards-compatible change. The "status-description" SHOULD be used to explain why the node is not available anymore.</t>
            </list>
            </t>
         </section>

         <section anchor="type_change" title="Changing the type of a leaf node">            
            <t>Changing the type of a leaf-node. e.g. consider a "vpn-id" node of type integer being changed to a string:
            <list style="numbers">
               <t>The status of node "vpn-id" SHOULD be changed to "deprecated" and the node SHOULD be available for at least one year. This is a backwards-compatible change.</t>
               <t>A new node, e.g. "vpn-name", of type string is added to the same location as the existing node "vpn-id". This new node has status "current" and its description SHOULD explain that it is replacing node "vpn-id".</t>
               <t>During the period of time where both nodes are available, how the server behaves when either node is set is outside the scope of this document. Here are some options:
               <list style="numbers">
                  <t>A server MAY prevent the new node from being set if the old node is already set (and vice-versa). The new node MAY have a when statement to achieve this. The old node MUST NOT have a when statement since this would be a non-backwards-compatible change, but the server MAY reject the old node from being set if the new node is already set.</t>
                  <t>If the new node is set and a client does a get or get-config operation on the old node, the server MAY map the value. For example, if the new node "vpn-name" has value "123" then the server MAY return integer value 123 for the old node "vpn-id". However, if the value can not be mapped, we need a way of returning "unsupported" TBD.</t>
               </list>
               </t>
               <t>When node "vpn-id" is not available anymore, its status MUST be changed to "obsolete" and the "status-description" is updated. This is a non-backwards-compatible change.</t>
            </list>
            </t>
         </section>
         
         <section anchor="range_reduction" title="Reducing the range of a leaf node">
         </section>

         <section anchor="key_change" title="Changing the key of a list">
         </section>

         <section anchor="rename_node" title="Renaming a node">
         </section>

         <section anchor="default_change" title="Changing a default value">
         </section>

       </section>
   </section>
   <section anchor="guidelines_clients" title="Guidelines to YANG model clients">
      <t>Here are some guidelines for YANG model clients:
         <list style="symbols">
            <t>Clients SHOULD be liberal when processing data received from a server. For example, the server may have increased the range of an operational node causing the client to receive a value whch is outside the range of the YANG model revision it was coded against</t>
            <t>Clients SHOULD look for status changes in new revisions of YANG models they support.</t>
            <t>Clients SHOULD plan to make changes to match published status changes. When a node's status changes from "current" to "deprecated", clients SHOULD plan to stop using that node in a timely fashion. When a node's status changes to "obsolete", clients MUST stop using that node.</t>
            <t>A client SHOULD not use unknown NBC versions automatically</t>
         </list> 
      </t>
   </section>
</section>

<section anchor="yang_module" title="Semantic Version Extension YANG Module">
  <t>
    The extension and related ietf-yang-library changes described in this module are
    defined in the YANG module below.
  </t>
  <t>TODO - Define a separate type (in a ietf-semver-types.yang) file
  for the YANG semver field definition.  It would be useful for the YANG
  library augmentation, and possibly in the packages definition if that
  work progresses.</t>
  <t>TODO - Update the semantic version text to update the main definition in this document</t>
  <t>
    <figure>
      <artwork><![CDATA[
<CODE BEGINS> file "ietf-semver@2018-04-05.yang"
  module ietf-semver {
    yang-version 1.1;
    namespace "urn:ietf:params:xml:ns:yang:ietf-semver";
    prefix semver;

    import ietf-yang-library {
      prefix yanglib;
    }

    organization
      "IETF NETMOD (Network Modeling) Working Group";
    contact
      "WG Web:   <https://datatracker.ietf.org/wg/netmod/>
       WG List:  <mailto:netmod@ietf.org>

       Author:   Benoit Claise
                 <mailto:bclaise@cisco.com>

       Author:   Joe Clarke
                 <mailto:jclarke@cisco.com>

       Author:   Kevin D'Souza
                 <mailto:kd6913@att.com>

       Author:   Balazs Lengyel
                 <mailto:balazs.lengyel@ericsson.com>";
    description
      "This module contains a definition for a YANG 1.1 extension to
       express the semantic version of YANG modules.";

    revision 2018-04-05 {
      description
        "* Properly import ietf-yang-library.
         * Fix the name of module-semver => module-version.
         * Fix regular expression syntax.
         * Augment yang-library with booleans as to whether or not
           deprecated and obsolete nodes are present.
         * Add an extension to enable import by semantic version.
         * Add an extension status-description to track deprecated
           and obsolete reasons.
         * Fix yang-library augments to use 7895bis.";
      reference
        "draft-clacla-netmod-yang-model-update:
         New YANG Module Update Procedure";
      semver:module-version "0.2.1";
    }
    revision 2017-12-15 {
      description
        "Initial revision.";
      reference
        "draft-clacla-netmod-yang-model-update:
         New YANG Module Update Procedure";
      semver:module-version "0.1.1";
    }

    extension module-version {
      argument semver;
      description
        "The version number for the module revision it is used in.
         This is expressed as a semantic version string in the form:
          x.y.z
         where:
          * x corresponds to the major version,
          * y corresponds to a minor version,
          * z corresponds to a patch version.

         A major version number of 0 indicates that this model is still
         in development, and is potentially subject to change.

         Following a release of major version 1, all modules will
         increment major revision number where backward incompatible
         changes to the model are made.

         The minor version is changed when features are added to the
         model that do not impact current clients use of the model.
         When major version is stepped, the minor version is reset to 0.

         The patch-level version is incremented when non-feature changes
         (such as bugfixes or clarifications to human-readable
         descriptions that do not impact model functionality) are made
         that maintain backward compatibility.
         When major or minor version is stepped, the patch-level is
         reset to 0.

         By comparing the module-version between two revisions of a
         given module, one can know if different revisions are backward
         compatible or not, as well as
         whether or not new features have been added to a newer revision.

         If a module contains this extension it indicates that for this
         module the updated status and update rules as this described in
         RFC XXXX are used.

         The statement MUST only be a substatement of the revision statement.
         Zero or one module-version statement is allowed per parent
         statement. NO substatements are allowed.
        ";
      reference "I-D.clacla-netmod-yang-model-update : YANG Semantic Version";
    }

    extension import-versions {
      argument version-clause;
      description
        "This extension specifies an acceptable set of semantic versions of a given module
         that may be imported.  The version-clause argument is specified in the following
         format

         [\\[(]X[.Y[.Z]][-[X[.Y[.X]]][\\])]][,...]

         Where the first character MAY be a '[' or '(' to indicate at least inclusive and at least
          exclusive (respectively).  If this is omitted, a full semantic version must be specified
          and the import will only support this one version.

         The following version, if specified with a '[' or '(' indicates the lower bound.  This can
          be a full semantic version or a MAJOR only or MAJOR.MINOR only.

         The '-', if specified, is a literal hyphen indicating a range will be specified.  If the second portion
          of the import-versions clause is omitted, then there is no upper bound on what will be considered
          an acceptable imported version.

         After the '-' the upper bound semantic version (or part thereof) follows.
         After the upper bound version, one of ']' or ')' MUST follow to indicate whether this limit is inclusive
          or exclusive of the upper bound respectively.

         Finally, a literal comma (',') MAY be specified with additional ranges.  Each range is taken as a logical
          OR.

         The statement MUST only be a substatement of the import statement.  Zero or one
         import-versions statement is allowed per import statement.  NO substatements are allowed.";
      reference "I-D.clacla-netmod-yang-model-update : Import By Semantic Version";
    }

    extension status-description {
      argument description;
      description
        "Freeform text that describes why a given node has been deprecated or made obsolete.
         This may point to other schema elements that can be used in lieu of the given node.

         This statement MUST only be used as a substatement of the status statement, and MUST
         only be used when the status is deprecated or obsolete.  Zero or more status-description
         statements are allowed per parent statement.  NO substatements are allowed.";
      reference "I-D.clacla-netmod-yang-model-update : Deprecated and Obsolete Reasons";
    }

    augment "/yanglib:yang-library/yanglib:module-set/yanglib:module" {
      description
        "Augmentations for the ietf-yang-library module to support semantic versioning.";
      leaf module-version {
        type string {
          pattern '[0-9]+\.[0-9]+\.[0-9]+';
        }
        description
          "The semantic version for this module in MAJOR.MINOR.PATCH format.  This version
           must match the semver:module-version value in specific revision of the module
           loaded in this module-set.";
      }
      leaf deprecated-nodes-present {
        type boolean;
        default "true";
        description
          "A boolean that indicates whether or not this server implements deprecated nodes.
           The value of this leaf SHOULD be true; and if so, the server MUST implement nodes
           within this module as they are documented.  If specific deprecated nodes are not
           implemented as document, then they MUST be listed as deviations.  If a module does
           not currently contain any deprecated nodes, then this leaf SHOULD be set to true.";
      }
      leaf obsolete-nodes-present {
        type boolean;
        default "false";
        description
          "A boolean that indicates whether or not this server implements obsolete nodes.
           The value of this leaf SHOULD be false; and if so, the server MUST NOT implement
           nodes within this module. If this leaf is true, then all nodes in this module MUST
           be implemented as documented in the module.  Any variation of this MUST be listed as
           deviations.  If a module does not currently contain any obsolete nodes, then this
           leaf SHOULD be set to true.";
      }
    }
  }
<CODE ENDS>
]]></artwork>
</figure>
</t>
</section>

<section anchor="contributor" title="Contributors">
  <t>
   <list style="symbols">
     <t>Anees Shaikh, Google
     </t>
     <t>Rob Shakir, Google
     </t>
   </list>
  </t>
</section>

<section anchor="security" title="Security Considerations">
  <t>
 The document does not define any new protocol or data model.
 There are no security impacts.
 </t>
</section>
<section anchor="iana" title="IANA Considerations">
  <section anchor="yang-module-registrations" title="YANG Module Registrations">
  <t>The following YANG module is requested to be registred in the "IANA
  Module Names" registry:</t>

  <t>The ietf-semver module:</t>

  <t><list style="symbols">
    <t>Name: ietf-semver</t>
    <t>XML Namespace: urn:ietf:params:xml:ns:yang:ietf-semver</t>
    <t>Prefix: semver</t>
    <t>Reference: [RFCXXXX]</t>
  </list></t>
</section>
</section>
</middle>
<?rfc needLines="20"?>
<back>
<references title="Normative References">
   <?rfc include='reference.RFC.7950'?>
   <?rfc include='reference.RFC.7895'?>
   <?rfc include='reference.RFC.8407'?>
   <?ref include='reference.I-D.verdt-netmod-yang-versioning-reqs'?>
</references>
<references title="Informative References">
   <?rfc include='reference.I-D.openconfig-netmod-model-catalog'?>
   <?rfc include='reference.I-D.claise-semver'?>
   <?rfc include='reference.I-D.clacla-netmod-model-catalog'?>
   <?rfc include='reference.I-D.ietf-netconf-rfc7895bis'?>
   <reference anchor="openconfigsemver" target="http://www.openconfig.net/docs/semver/">
     <front>
      <title>Semantic Versioning for Openconfig Models</title>
      <author/>
      <date/>
    </front>
   </reference>
      <reference anchor="semver" target="https://www.semver.org">
      <front>
       <title>Semantic Versioning 2.0.0</title>
       <author/>
       <date/>
    </front>
   </reference>
   <reference anchor="yangcatalog" target="https://yangcatalog.org">
     <front>
       <title>YANG Catalog</title>
       <author/>
       <date/>
     </front>
   </reference>
</references>
<?rfc needLines="100"?>

<section anchor="appendix" title="Appendix">
  <section anchor="open_issues_reqs" title="Open Issues: Requirements to be Addressed">
    <t>
        There are a few requirements of
        <xref target="I-D.verdt-netmod-yang-versioning-reqs"/> still to be addressed.  These include the following:
    </t>

    <t>
      <list style="symbols">
        <t>A solution is required for client compatibility to address requirements 3.1 and 3.2 from <xref target="I-D.verdt-netmod-yang-versioning-reqs"/>.
        This could include adding "module sets" support to ietf-yang-library where the client can choose one set with which to use.</t>
        <t>A solution for instance data to satisfy requirement 5.3 of <xref target="I-D.verdt-netmod-yang-versioning-reqs"/> is also required.</t>
        <t>While not mandatory, requirement 2.2 of <xref target="I-D.verdt-netmod-yang-versioning-reqs"/> looks to provide a way to determine,
        at the node level, whether or not changes have occurred between revisions of a given YANG module.  This may require application
        of semver at the node level.</t>
      </list>
    </t>
  </section>
  <section anchor="open_issues" title="Open Issues">
    <t>Additionally, there are a few open issues to be discussed and settled.  These include the following:</t>

    <t>
      <list style="symbols">
        <t>Do we need a new version of YANG?
          <vspace/>
          While eventually this will fold into a new version, the belief is this solution can
          work with extensions alone with an update to the <xref target="RFC7950"/> text concerning
          module updates.</t>
        <t>Should IETF/IANA officially generate derived semantic versions for their own modules?
        As they are the owner of the modules it should be their responsibility, but how to document it?
		Note that next round of funding for the yangcatalog.org could help develop the perfect
		derived-semantic-version toolset
        </t>
        <t>We could consider a new naming convention for module files. Today, module files
          are named using a  module@revision.yang notation.  We could consider module%semver.yang
          or module#version.yang variants.
          Re-using the '@' for version is not ideal, so another separator character should be used.
          In this manner, both version and revision could be used.
          </t>
      </list>
    </t>
  </section>
  <section anchor="derived_semver" title="Derived Semantic Version">
    <t>TODO - Ideally this text would move to a separate schema
    comparison tool draft, but keep the text here until that draft has
    been started.</t>
    <section anchor="the_derived_semantic_versioning" title="The Derived Semantic Version">
      <t>
	If an explicitly defined semantic version is not available in
	the YANG module, it is possible to algoritmically calculate a
	derived semantic version. This can be used for modules not
	containing a definitive semantic-version as defined in this
	document or as a starting value when specifying the definitive
	semantic-version. Be aware that this algorithm may sometimes
	incorrectly classify changes between the categories
	non-compatible, compatible or error-correction.
	</t>
    </section>
    <section anchor="implementation_experience" title="Implementation Experience">
      <t>
	<xref target="yangcatalog"/> uses the pyang utility to calculate
	the derived-semantic-version for all of the modules contained
	within the catalog.  <xref target="yangcatalog"/> contains many
	revisions of the same module in order to provide its
	derived-semantic-version for module consumers to know what has
	changed between revisions of the same module.
      </t>
      <t>
	Two distinct leafs in the YANG module <xref target="I-D.clacla-netmod-model-catalog"/> contain this semver notation:
      </t>
      <t>
	<list style="symbols">
	  <t>the semantic-version leaf contains the value embedded
	  within a YANG module (if it is available).
	  </t>
	  <t>the derived-semantic-version leaf is established by
	  examining the the YANG module themselves.  As such
	  derived-semantic-version only takes syntax into account as
	  opposed to the meaning of various elements when it computes
	  the semantic version.</t>

	  <t>The algorithm used to produce the derived-semantic-version is as follows:
            <list style="numbers">
              <t>Order all modules of the same name by revision from
              oldest to newest.  Include module revisions that are not
              available, but which are defined in the revision
              statements in one of the available module versions. </t>
              <t>If module A, revision N+1 has failed compilation, bump
              its derived semantic MAJOR version.  For unavailable
              module versions assume non-backward compatible changes
              were done., thus bump its derived semantic MAJOR
              version.</t>
              <t>Else, run "pyang --check-update-from" on module A,
              revision N and revision N+1 to see if
              backward-incompatible changes exist.</t>
              <t>If backward-incompatible changes exist, bump module A,
              revision N+1's derived MAJOR semantic version.</t>
              <t>If no backward-incompatible changes exist, compare the
              pyang trees of module A, revision N and revision N+1.</t>
              <t>If there are structural differences (e.g., new nodes),
              bump module A, revision N+1's derived MINOR semantic
              version.</t>
              <t>If no structural differences exist, bump module A,
              revision N+1's derived PATCH semantic version.</t>
            </list>
          </t>
	</list>
      </t>
      <t>
	The pyang utility checks many of the points listed in section 11
	of <xref target="RFC7950"/> for known module incompatibilities.
	While this approach is a good way to programmatically obtain a
	semantic version number, it does not address all cases whereby a
	major version number might need to be increased.  For example, a
	node may have the same name and same type, but its meaning may
	change from one revision of a module to another.  This
	represents a semantic change that breaks backward compatibility,
	but the above algorithm would not find it.  Therefore,
	additional, sometimes manual, rigor must be done to ensure a
	proper version is chosen for a given module revision.
      </t>
    </section>
  </section>
</section>
</back>
</rfc>
<!-- Local Variables: -->
<!-- fill-column:72 -->
<!-- End: -->
